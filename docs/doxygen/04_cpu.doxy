/** @page riscv_core_page RISC-V Processor Core

  Basic tasks of Central Processor Unit (CPU) are:

\li Fetch and decode instructions
\li Supply operands for the Arithmetic and Logic unit (ALU), the Integer Multiply
and Divide block and for the Floating Pointing Unit (FPU) if enabled.
\li Load and Store data operands of the instructions

  River CPU implements five-stage pipeline with the possibility to \c Halt execution
at any time without neccessity of pipeline flushing. \c Halt signal itself can be
generated by User via Debug Support Unit (DSU) or by modules inside of pipeline.
This architecture allows to proccess several instructions in parallel and provides
functionality of the Debug Mode at any time.

  Moreover, processor River provides <b>non-invasive debugging</b> access that allows
to read/modify processors registers without halting the pipeline.

<center>
 <img src="../doxygen/pics/river_top.png" alt="Top Level"> 
 @latexonly {\includegraphics{../doxygen/pics/river_top.png}} @endlatexonly

@latexonly \begin{figid} @endlatexonly
Functional diagram of the River CPU.
@latexonly \end{figid} @endlatexonly
</center>

  RISC-V Core \c River continues developing to support new instructions sets
and improve performance. The following table contains brief information
about already implemented features and features that are now in the development.

<center>
<table>
  <tr>
    <th>Function</th> <th>River, the latest ver.</th> <th>Description</th>
  </tr>
  <tr>
    <td>RISC-V User Level spec</td>  <td>2.2</td>   <td>See
         <a href=https://riscv.org/specifications/>riscv.org.</a></td>
  </tr>
  <tr>
    <td>RISC-V Priviledged Level spec</td>  <td>1.10</td>   <td>See
         <a href=https://riscv.org/specifications/>riscv.org.</a></td>
  </tr>
  <tr>
    <td>GCC version</td>  <td>7.2.2 or newer</td>   <td>Used as a default
       toolchain in the open-source repository</td>
  </tr>
  <tr>
    <td>GCC for Windows.</td>  <td>Yes</td>   <td>Cross-platform
        toolchain is available for a different OS</td>
  </tr>
  <tr>
    <td>C-extension</td>  <td>Yes</td>   <td>Compressed (16-bit)
        instructions set support</td>
  </tr>
  <tr>
    <td>D-extension</td>  <td>Yes</td>   <td>Double precision
       (64-bits) floating point instructions set</td>
  </tr>
  <tr>
    <td>F-extension</td>  <td>Partially</td>   <td>Single precision
       (32-bits) floating point instructions set not used in the current
        DSP algoritms. Full support will be added later or by request.</td>
  </tr>
  <tr>
    <td>Instruction Cache</td>  <td>Yes</td>   <td>Configurable
       IP. Default configurations: 4-ways, 16 KB, LRU</td>
  </tr>
  <tr>
    <td>Data Cache</td>  <td>Yes</td>   <td>Configurable
       IP. Default configurations: 4-ways, 16 KB, LRU.</td>
  </tr>
  <tr>
    <td>Memory Protection Unit</td>  <td>Yes</td>   <td>Configurable
       number of MPU entries. Programmable: region size, caching enable/disable,
       read-write-execute access rights.</td>
  </tr>
  <tr>
    <td>Brach Predictor</td>  <td>Yes</td>   <td>Improve CPI
     performance index on 15 %</td>
  </tr>
  <tr>
    <td>Stack Protection</td>  <td>Yes</td>   <td>Generate
       exceptions on stack overflow or underflow events. This extension implements
       custom Control and Status Registers (CSR) in CPU.</td>
  </tr>
  <tr>
    <td>A-extension</td>  <td>Planned</td>   <td>Atomic instructions
        set support.</td>
  </tr>
  <tr>
    <td>Watchdog</td>  <td>Planned</td>   <td>Generate reset signal if there's
       no CPU activity specified number of clock cycles.</td>
  </tr>
</table>

@latexonly \begin{tblid} @endlatexonly
RIVER CPU features list.
@latexonly \end{tblid} @endlatexonly
</center>


 @section riverlib_generic_section Generic Configuration

  River CPU implementation shared as IP block writen on VHDL. All source files
should be placed in \c riverlib VHDL library before compilation. The following
main generic parameters are avaiable for the user configuration.

<center>
<table>
  <tr>
    <th>Name</th>    <th>Value</th>   <th>Description</th>
  </tr>
  <tr>
    <td>async_reset</td>
    <td>FALSE</td>
    <td><b>Reset Type</b>. Internal registers reset type:
       <ul>
         <li>FALSE: syncrhonous reset (FPGA)</li>
         <li>TRUE: asynchronous reset (ASIC)</li>
       </ul></td>
  </tr>
  <tr>
    <td>CFG_VENDOR_ID</td>
    <td>X"000000F1"</td>
    <td><b>Vendor ID</b>. Hardcoded constant available for reading in
       standard CSR register described in RISC-V ISA</td>
  </tr>
  <tr>
    <td>CFG_IMPLEMENTATION_ID</td>
    <td>X"20190512"</td>
    <td><b>Implementation ID</b>. Hardcoded constant available for reading in
       standard CSR register described in RISC-V ISA.</td>
  </tr>
  <tr>
    <td>CFG_HW_FPU_ENABLE</td>
    <td>true</td>
    <td><b>Enable FPU</b>. Enable/disable FPU IP:
       <ul>
         <li>FALSE: Disable FPU</li>
         <li>TRUE: Enable FPU</li>
       </ul></td>
  </tr>
  <tr>
    <td>RISCV_ARCH</td>
    <td>64</td>
    <td><b>Architecture Size</b>. General CPU registers bit width:
       <ul>
         <li>32: RISC-V 32-bit not supproted</li>
         <li>64: RISC-V 64-bit</li>
         <li>128: RISC-V 128-bit not supported</li>
       </ul></td>
  </tr>
  <tr>
    <td>BUS_ADDR_WIDTH</td>
    <td>32</td>
    <td><b>System Bus Width</b>. Typicall value (other values acceptable but not tested):
       <ul>
         <li>32: Use 32-bits address bus (default)</li>
         <li>64: Use 64-bits address bus</li>
       </ul></td>
  </tr>
  <tr>
    <td>CFG_LOG2_DATA_BYTES</td>
    <td>3</td>
    <td><b>Data Bus Bytes</b> parameter. Logarithmic value of System Data Bus in Bytes.
       <ul>
         <li>3: Number of bytes 2**3 = 8 (64 bits)</li>
       </ul></td>
  </tr>
  <tr>
    <td>CFG_ILOG2_BYTES_PER_LINE</td>
    <td>5</td>
    <td><b>Bytes per Lane</b>. Logarithmic value of Bytes per one I-cache line.
       This value and Data Bus width define length of one burst transaction
       when cached memory access is used.
       <ul>
         <li>4: 32 Bytes per I-cache line. Burst length 4 with 64-bits data bus</li>
         <li>5: 64 Bytes per I-Cache line. Burst length 8 with 64-bits data bus</li>
       </ul></td>
  </tr>
  <tr>
    <td>CFG_ILOG2_LINES_PER_WAY</td>
    <td>7</td>
    <td><b>Lines Per Way</b>. Logarithmic value defines I-cache size or
       number of lines instantiated for the each way:
       <ul>
         <li>1: Analog of Cache disabled</li>
         <li>7: 128 lines per Way. (16 KB in default configuration)</li>
         <li>8: 256 lines Way.</li>
         <li>9: 512 lines Way.</li>
       </ul></td>
  </tr>
  <tr>
    <td>CFG_ILOG2_NWAYS</td>
    <td>2</td>
    <td><b>Number of Way</b>. Logarithmic value defines I-cache associativity:
       <ul>
         <li>2: 4 Ways. (default)</li>
         <li>3: 8 Ways.</li>
       </ul></td>
  </tr>
  <tr>
    <td>CFG_DLOG2_BYTES_PER_LINE</td>
    <td>5</td>
    <td><b>Bytes per Lane</b>. Logarithmic value of Bytes per one D-cache line.
       This value and Data Bus width define length of one burst transaction
       when cached memory access is used.
       <ul>
         <li>4: 32 Bytes per D-cache line. Burst length 4 with 64-bits data bus</li>
         <li>5: 64 Bytes per D-Cache line. Burst length 8 with 64-bits data bus</li>
       </ul></td>
  </tr>
  <tr>
    <td>CFG_DLOG2_LINES_PER_WAY</td>
    <td>7</td>
    <td><b>Lines Per Way</b>. Logarithmic value defines D-cache size or
       number of lines instantiated for the each way:
       <ul>
         <li>1: Analog of Cache disabled</li>
         <li>7: 128 lines per Way. (16 KB in default configuration)</li>
         <li>8: 256 lines Way.</li>
         <li>9: 512 lines Way.</li>
       </ul></td>
  </tr>
  <tr>
    <td>CFG_DLOG2_NWAYS</td>
    <td>2</td>
    <td><b>Number of Way</b>. Logarithmic value defines D-cache associativity:
       <ul>
         <li>2: 4 Ways. (default)</li>
         <li>3: 8 Ways.</li>
       </ul></td>
  </tr>
  <tr>
    <td>CFG_MPU_TBL_WIDTH</td>
    <td>2</td>
    <td><b>MPU table length</b>. Logarithmic value defines number of entries
       (memory regions) supported by Memory Protection Unit:
       <ul>
         <li>2: 4 regions (default)</li>
         <li>3: 8 regions.</li>
         <li>4: 16 regions.</li>
       </ul></td>
  </tr>
</table>

@latexonly \begin{tblid} @endlatexonly
RIVER generic parameters.
@latexonly \end{tblid} @endlatexonly
</center>

 @section cpu_mpu_section Memory Protection Unit

  The MPU based <i>Protected Memory System Architecture</i> provides a 
considerably simpler memory protection scheme than the MMU based model
providing the <i>Virtual Memory System Architecture</i>. The simplification
applies to both the hardware and the software.

  Main simplification is that the MPU does not use translation tables.
Instead, Control and Status Registers (CSRs) are used to fully define
<i>protection regions</i>, eliminating the need for hardware to do translation
table walks, and for software to set up and maintain the translation tables.
This has the benefit of making memory checking fully determenistic.
However, the level of control is now region based rater than page based, that is,
the control is considerably less fine-grained.

  A second simplification is that virtual-to-physical address translation
is not supported. Processor works only with the physical addresses.
The following feature are common to all MPU based designs:

\li The memory is divided into regions. Dedicated Control registers are
    used to to define the region size, base address, and memory attributes,
    for example, cachability and access permissions of a region.

\li Memory region control (read and write access) is permitted only
    from priviledged modes.

\li If an address is defined in multiple regions, a fixed priority scheme
    (highest region number) is used to define the properties of the address
    being accessed.

\li All addresses are physical addresses, address translation is not supported.

 @subsection mpu_memaccess_sequence Memory access sequence

  When River CPU generated a memory access, the I/D cache systems check
availability of data inside of it. If the <i>miss</i> signal generated
MPU compares the memory address with the programmed memory regions:

\li If the memory region marked as uncached cache subsystem generates
    memory request directly into system bus interface without storing
    response into cache memory.

\li If the memory region marked as cachable the cache subsystem generates
    memory burst request to read full cache line (on read operation) or
    read-modify-write to cache memory on write operation.

\li If the memory region is enabled and access rights do not allow to 
    complete operation then cache subsystem returns error response without
    access to system bus.

\li Current implementation of MPU allows to read, write and execute data
    for all disabled regions.

 @subsection mpu_overlapping_subsection Overlapping regions

  The Protection Unit can be programmed with two or more overlapping regions.
When overlapping regions are programmed, a fixed priority scheme is applied to
determine the region whose attributes are applied to memory access.

  For example, if the \c CFG_MPU_TBL_WIDTH = 3 enabling 8 programmable regions
then region 7 take the highest priority and region 0 takes lowest priority.
Lets suppose:

\li Data region 1 is programmed to be 16 KB in size, starting from address 0x0
    with the caching flag = 1.

\li Data region 2 is programmed 64 Bytes in size, starting from address 0x3000
    with the caching flag = 0.

  Then this 64 B of memory can be used for the inter-processor communication
without performance penalty on cache flushing operations because read and write
access will be re-directed on system bus without L1 caching.

<center>
<table>
  <tr>
    <th>Address</th>  <th>Enabled</th> <th>Cachable</th> <th>Read</th> <th>Write</th> <th>Execute</th>
  </tr>
  <tr>
    <td>0x00000000-0x7FFFFFFF</td>
    <td>TRUE</td>
    <td>TRUE</td>
    <td>TRUE</td>
    <td>TRUE</td>
    <td>TRUE</td>
  </tr>
  <tr>
    <td>0x80000000-0xFFFFFFFF</td>
    <td>TRUE</td>
    <td>FALSE</td>
    <td>TRUE</td>
    <td>TRUE</td>
    <td>FALSE</td>
  </tr>
</table>

@latexonly \begin{tblid} @endlatexonly
Default memory map.
@latexonly \end{tblid} @endlatexonly
</center>

 @subsection mpu_csr_subsection Memory access control

  The following RTL /i River Configuration parameter specify the addresses of
exceptions handlers for MPU:

<table>
  <tr>
    <th>Parameter</th> <th>Value</th> <th>Description</th>
  </tr>
  <tr>
    <td>CFG_NMI_INSTR_PAGE_FAULT_ADDR</td>   <td>00000068h</td>   <td>Execute 
       instruction from the enabled region with the attribute \i executable = FALSE</td>
  </tr>
  <tr>
    <td>CFG_NMI_LOAD_PAGE_FAULT_ADDR</td>   <td>00000070h</td>   <td>Load 
       data from the enabled region with the attribute \i readable = FALSE</td>
  </tr>
  <tr>
    <td>CFG_NMI_STORE_PAGE_FAULT_ADDR</td>   <td>00000078h</td>   <td>Store
       data into the enabled region with the attribute \i writable = FALSE</td>
  </tr>
</table>


  Access to a memory region is controlled by River CPU specific Control and Status
Registers (CSRs).

<b>CSR_MPU_ADDR Register (0x352)</b>

<table>
  <tr>
    <th>Field</th> <th>Bits</th> <th>Type</th> <th>Description</th>
  </tr>
  <tr>
    <td>reserved</td>   <td>[63:BUS_ADDR_WIDTH]</td>   <td>WO</td>   <td><b></b>.</td>
  </tr>
  <tr>
    <td>ADDR</td>   <td>[BUS_ADDR_WIDTH-1:0]</td>   <td>WO</td>   <td><b>MPU Address</b>.
     Base address of programming region. This value applied to the MPU region on write
     access into the register \c CSR_MPU_CTRL</td>
  </tr>
</table>

<b>CSR_MPU_MASK Register (0x353)</b>

<table>
  <tr>
    <th>Field</th> <th>Bits</th> <th>Type</th> <th>Description</th>
  </tr>
  <tr>
    <td>reserved</td>   <td>[63:BUS_ADDR_WIDTH]</td>   <td>WO</td>   <td><b></b>.</td>
  </tr>
  <tr>
    <td>MASK</td>   <td>[BUS_ADDR_WIDTH-1:0]</td>   <td>WO</td>   <td><b>MPU Address Mask</b>.
     Address mask defining region size. This value applied to the MPU region on write
     access into the register \c CSR_MPU_CTRL.</td>
  </tr>
</table>

<b>CSR_MPU_CTRL Register (0x354)</b>

<table>
  <tr>
    <th>Field</th> <th>Bits</th> <th>Type</th> <th>Description</th>
  </tr>
  <tr>
    <td>IDX</td>   <td>[15:8]</td>   <td>RW</td>   <td><b>Region Index</b>.
     This field specify region index that will be modified on write access to this
     register on write access.
     This value contains total number of available regions \c CFG_MPU_TBL_SIZE
     on read access</td>
  </tr>
  <tr>
    <td>ENA</td>   <td>[4]</td>   <td>WO</td>   <td><b>Region Enable</b>.
     Enable region:
       \li 0 = region disabled (not used)
       \li 1 = region enabled</td>
  </tr>
  <tr>
    <td>CACHABLE</td>   <td>[3]</td>   <td>WO</td>   <td><b>Caching Enable</b>.
     Enable region for caching:
       \li 0 = caching disabled
       \li 1 = caching enabled</td>
  </tr>
  <tr>
    <td>EXEC</td>   <td>[2]</td>   <td>WO</td>   <td><b>Execute Enable</b>.
     Enable region for the instruction execution:
       \li 0 = execution disabled
       \li 1 = execution enabled</td>
  </tr>
  <tr>
    <td>RD</td>   <td>[1]</td>   <td>WO</td>   <td><b>Read Enable</b>.
     Enable region for reading:
       \li 0 = read disabled
       \li 1 = read enabled</td>
  </tr>
  <tr>
    <td>WR</td>   <td>[0]</td>   <td>WO</td>   <td><b>Write Enable</b>.
     Enable region for writing:
       \li 0 = write disabled
       \li 1 = write enabled</td>
  </tr>
</table>

 @subsection mpu_example_section C-code example

  The following C-example shows how to read total available memory regions
provided by MPU:

@code
    // 0x354 = CSR_MPU_CTRL:
    int get_region_total() {
        int ret;
        asm("csrr %0, 0x354" : "=r" (ret));
        return (ret >> 8) 0xFF;
    }
@endcode

  Example of methods that controlling specific memory region via CSRs registers:

@code
    // CSR register CSR_MPU_CTRL
    typedef union mpu_ctrl_type {
        struct bits_type {
            uint64_t WR    : 1;     // [0]
            uint64_t RD    : 1;     // [1]
            uint64_t EXEC  : 1;     // [2]
            uint64_t CACHABLE : 1;  // [3]
            uint64_t ENA    : 1;    // [4]
            uint64_t rsrv1  : 3;    // [7:5]
            uint64_t IDX    : 8;    // [15:8]
            uint64_t rsrv2  : 48;   // 
        } bits;
        uint64_t value;
    } mpu_ctrl_type;


    // Enable MPU region with the specifc rights:
    void mpu_enable_region(int idx,            // MPU entry index
                           uint64_t bar,       // Memory region base address
                           uint64_t KB,        // Memory region size in KB
                           int cached,         // 1=cached; 0=uncached
                           const char *rwx) {  // Region access rights string
        uint64_t mask = (~0ull) << 10;
        const char *p = rwx;
        mpu_ctrl_type ctrl;

        // Write base address
        asm("csrw 0x352, %0" : :"r"(bar));

        // Computes region mask using KB value
        KB >>= 1;
        while (KB) {
            mask <<= 1;
            KB >>= 1;
        }
        asm("csrw 0x353, %0" : :"r"(mask));

        // Write Control word
        ctrl.value = 0;
        ctrl.bits.IDX = idx;
        ctrl.bits.ENA = 1;
        ctrl.bits.CACHABLE = cached;
        while (*p) {
            if (*p == 'r') {
                ctrl.bits.RD = 1;
            }
            if (*p == 'w') {
                ctrl.bits.WR = 1;
            }
            if (*p == 'x') {
                ctrl.bits.EXEC = 1;
            }
            p++;
        }
        asm("csrw 0x354, %0" : :"r"(ctrl.value));
    }

    // Disable MPU region
    void mpu_disable_region(int idx) {
        mpu_ctrl_type ctrl;
        ctrl.value = 0;
        ctrl.bits.IDX = idx;
        asm("csrw 0x354, %0" : :"r"(ctrl.value));
    }
@endcode

  The following C-example demonstrates procedures of interaction
with the MPU module that allows to configure, enable and disable certain
memory regions access rights using previously defined methods.

@code
    // Test function
    void test_mpu() {
        int reg_total = get_region_total();

        // Make 0x20000..0x20FFF region:
        //       uncached
        //       read, write, not executable
        mpu_enable_region(reg_total-1, 0x20000, 4, 0, "rw")
        ..
        mpu_disable_region(reg_total-1);
    }
@endcode


 @section cpu_prefetch_section Program Flow Control

  The Instruction Fetch Unit prefetches and preprocesses instructions to
provide a continuous instruction flow. Fetch module continuously requests 32-bits
instruction words (1-standard or 2-compressed instructions) on each clock cycle.

  If Instruction Cache module cannot return data on the next clock
cycle Fetch module generates <c>hold pipeline</c> signal.
<c>Hold pipeline</c> signal released when \c ICache module returns valid data.
Typically it will take 6 clock cycles to request and save 4-clock burst transaction.

  Preprocessing of branch instructions enables the instruction flow to be predicted.
While the CPU is in the process of decoding and executing an instruction the fetcher
starts to request a new instruction at a predicted target address. Even for a
non-sequential instruction execution, Branch Predictor and Fetcher can
generally provide a continuous instruction flow.

  During the prefetch stage, the The Branch Predictor logic analyzes up to
three prefetched instructions stored in history buffer. If a branch is detected,
then the fetcher starts to request the next instructions from the instruction
cache accordingly to the predicted rules.

 @subsection cpu_predict_subsection Branch Prediction Rules

  The Branch Predictor preprocesses instructions and classifies detected branches.
Depending on the branch class, the Branch Predictor predicts the program flow
using the following rules:

<center>
<table>
  <tr>
    <th>Branch Instruction Classes</th> <th>Instructions</th> <th>Prediction Rule</th>
  </tr>
  <tr>
    <td>Unconditional Jump</td>  <td>JAL, C_J</td>   <td>The branch is always taken</td>
  </tr>
  <tr>
    <td>Return instructions</td>  <td>RET</td>   <td>The branch is always taken</td>
  </tr>
  <tr>
    <td>Conditional Branches</td>  <td>BEQ, BNE, BLT, BGE, BLTU, BGEU</td>   
        <td> Offset direction:
            \li Unconditional or backward: branch 'taken'
            \li Conditional forward: branch 'not taken'
        </td>
  </tr>
  <tr>
    <td>Relative Jump</td>  <td>JALR</td>   <td>The branch is always not taken</td>
  </tr>
  <tr>
    <td>Standard 4-bytes instruction</td>  <td>*</td>   <td>npc = pc + 4</td>
  </tr>
  <tr>
    <td>Compressed 2-bytes instruction</td>  <td>*</td>   <td>npc = pc + 2</td>
  </tr>
</table>

@latexonly \begin{tblid} @endlatexonly
Branch Classes and Prediction Rules.
@latexonly \end{tblid} @endlatexonly
</center>

 @section general_register_section General Purpose Registers

  CPU RIVER provides one bank of 32 regsiters x0, x1, ... x31, called
General Purpose Registers (GPR), which can be accessed in one CPU cycle.
Each register is a 64-bits width and can be used as a 32-bits operand
in the RV32 (W) instructions. The GPRs are the working registers
of the arithmetic and logic units and also serve as address pointers for
indirect addressing modes.

  The register bank are access via 3-port register file providing the high
access speed required for the CPU's performance. At any time there's
available 2 registers for reading and 1 for writing. Additional
Debug Port provides debuging registers access via \c DSU.

<center>
| Register | ABI Name   | Description
|:--------:|:----------:|:-----------------------------------------
| x0       | r0         | Hard-wired zero
| x1       | ra         | Return address
| x2       | sp         | Stack pointer
| x3       | gp         | Global pointer
| x4       | tp         | Thread pointer
| x5       | t0         | Temporary/alternate link register
| x6       | t1         | Temporary register 1
| x7       | t2         | Temporary register 2
| x8       | s0/fp      | Saved register 0 / frame pointer
| x9       | s1         | Saved register 1
| x10      | a0         | Function argument 0 / return value 0
| x11      | a1         | Function argument 1 / return value 1
| x12      | a2         | Function argument 2
| x13      | a3         | Function argument 3
| x14      | a4         | Function argument 4
| x15      | a5         | Function argument 5
| x16      | a6         | Function argument 6
| x17      | a7         | Function argument 7
| x18      | s2         | Saved register 2
| x19      | s3         | Saved register 3
| x20      | s4         | Saved register 4
| x21      | s5         | Saved register 5
| x22      | s6         | Saved register 6
| x23      | s7         | Saved register 7
| x24      | s8         | Saved register 8
| x25      | s9         | Saved register 9
| x26      | s10        | Saved register 10
| x27      | s11        | Saved register 11
| x28      | t3         | Temporary register 3
| x29      | t4         | Temporary register 4
| x30      | t5         | Temporary register 5
| x31      | t6         | Temporary register 6

@latexonly \begin{tblid} @endlatexonly
Integer Registers bank.
@latexonly \end{tblid} @endlatexonly
</center>

  Register \c x0 (zero), \c x1  (return address) usage cannot be changed
by software and hardcoded on hardware level. But usage of all others
registers is specified for the compilers to provide Application
Binary Compatibility (ABI).

  Writing into register \c x0 doesn't lead to any modification and
can be interpreted as an empty operation.

 @section fpu_register_section FPU Registers

  River CPU implements additional registers bank with the 32 64-bit registers.
Configuration parameter \c CFG_HW_FPU_ENABLE allows to disable instantiation
of the bank if the FPU was disabled. 

<center>
| Register | ABI Name   | Description
|:--------:|:----------:|:-----------------------------------------
| f0       | ft0        | FP temporary register 0
| f1       | ft1        | FP temporary register 1
| f2       | ft2        | FP temporary register 2
| f3       | ft3        | FP temporary register 3
| f4       | ft4        | FP temporary register 4
| f5       | ft5        | FP temporary register 5
| f6       | ft6        | FP temporary register 6
| f7       | ft7        | FP temporary register 27
| f8       | fs0        | FP saved register 0
| f9       | fs1        | FP saved register 1
| f10      | fa0        | FP argument 0 / return value 0
| f11      | fa1        | FP argument 1 / return value 1
| f12      | fa2        | FP argument 2
| f13      | fa3        | FP argument 3
| f14      | fa4        | FP argument 4
| f15      | fa5        | FP argument 5
| f16      | fa6        | FP argument 6
| f17      | fa7        | FP argument 7
| f18      | fs2        | FP saved register 2
| f19      | fs3        | FP saved register 3
| f20      | fs4        | FP saved register 4
| f21      | fs5        | FP saved register 5
| f22      | fs6        | FP saved register 6
| f23      | fs7        | FP saved register 7
| f24      | fs8        | FP saved register 8
| f25      | fs9        | FP saved register 9
| f26      | fs10       | FP saved register 10
| f27      | fs11       | FP saved register 11
| f28      | ft3        | FP temporary register 3
| f29      | ft4        | FP temporary register 4
| f30      | ft5        | FP temporary register 5
| f31      | ft6        | FP temporary register 6

@latexonly \begin{tblid} @endlatexonly
Floating-Point Unit Registers bank.
@latexonly \end{tblid} @endlatexonly
</center>

@note The future version of River is planned with the additional \c generic
      parameter enabling and disabing FPU that will allow to setup configuration
      for each core separetely.


 @section csr_register_section Control and Status Registers

  Special privileged instructions provides access to the internal CPU
Control and Status Registers (CSR) set. In a common case, accordingly with the
RISC-V specification, read/write/modify access rights depends of the
current processor mode. If processor tries to execute privileged access to CSR
while in lower than neccessary privileged level, then special trap is generated
with the increased rights.

  This functionality is used for the hypervisor and others virtual platforms
development and either to provide operational system security when running user's
applications.

  Processor River of the latest revision supports and correctly handles states
in two modes: <c>Machine mode</c> (maximal privileged level) and <c>User mode</c>.
But <c>User mode</c> have the same set of CSR registers and the same access
rights as the <c>Machine mode</c>. This is actually RISC-V specification violation
that would be fixed in the future release, but for the current moment it raises
only security issues of working with operational system but it doesn't affect
the possibility to run multitasks environment.

<center>
| Addr. | Name              | Reset Value        | Description
|:-----:|:------------------|:-------------------|-------------------------------------
| 0x001 | FFLAGS            | 0x0                | FPU accrued Exceptions fields from FCSR
| 0x002 | FRM               | 0x8                | FPU dynamic Rounding Mode fields from FCSR
| 0x003 | FCSR              | 0x8                | FPU Control and Status register (FRM + FFLAGS)
| 0xf10 | MISA              | 80000000:00101108h | List of supported instruction sets
| 0xf11 | MVENDORID         | 00000000:000000F1h | Vendor ID: \c CFG_VENDOR_ID parameter
| 0xf12 | MARCHID           | 0x0                | Architecture ID
| 0xf13 | MIMPLEMENTATIONID | 00000000:20190521h | Implementation ID: \c CFG_IMPLEMENTATION_ID parameter
| 0xf14 | MHARTID           | 0x0                | Core ID in multi-processors system
| 0x041 | UEPC              | 0x0                | User program counter
| 0x300 | MSTATUS           | 00000000:00001800h | Machine mode status register
| 0x302 | MEDELEG           | 0x0                | Machine exception delegation
| 0x303 | MIDELEG           | 0x0                | Machine interrupt delegation
| 0x304 | MIE               | 0x0                | Machine interrupt enable bit
| 0x305 | MTVEC             | 0x0                | Machine Interrupts Table pointer
| 0x340 | MSCRATCH          | 0x0                | Machine scratch register
| 0x341 | MEPC              | 0x0                | Machine program counter
| 0x342 | MCAUSE            | 0x0                | Machine trap cause
| 0x343 | MBADADDR          | 0x0                | Machine bad address
| 0x344 | MIP               | 0x0                | Machine Interrupt pending
| 0x350 | MSTACKOVR<sup>1</sup> | 0x0            | Machine Stack Overflow limit
| 0x351 | MSTACKUND<sup>1</sup> | 0x0            | Machine Stack Underflow limit
| 0x352 | MPU_ADDR<sup>1</sup>  | 0x0            | MPU region Base address
| 0x353 | MPU_MASK<sup>1</sup>  | 0x0            | MPU region size
| 0x354 | MPU_CTRL<sup>1</sup>  | 0x0            | MPU Control Register

@latexonly \begin{tblid} @endlatexonly
List of implemented CSR registers.
@latexonly \end{tblid} @endlatexonly
</center>
<sup>1</sup> - Non-standard CSR register (River CPU only).

<b>FFLAGS Register (0x001)</b>

<table>
  <tr>
    <th>Field</th> <th>Bits</th> <th>Type</th> <th>Description</th>
  </tr>
  <tr>
    <td>reserved</td>   <td>[63:5]</td>   <td>RO</td>   <td><b></b>.</td>
  </tr>
  <tr>
    <td>NV</td>   <td>[4]</td>   <td>RO</td>   <td><b>Invalid Operation</b>.
     Last FPU operation status flag</td>
  </tr>
  <tr>
    <td>DZ</td>   <td>[3]</td>   <td>RO</td>   <td><b>Divide by Zero</b>.
     Last FPU operation status flag</td>
  </tr>
  <tr>
    <td>OF</td>   <td>[2]</td>   <td>RO</td>   <td><b>Overflow</b>.
     Last FPU operation status flag</td>
  </tr>
  <tr>
    <td>UF</td>   <td>[1]</td>   <td>RO</td>   <td><b>Underflow</b>.
     Last FPU operation status flag</td>
  </tr>
  <tr>
    <td>NX</td>   <td>[0]</td>   <td>RO</td>   <td><b>Inexact</b>.
     Last FPU operation status flag</td>
  </tr>
</table>

<b>FRM Register (0x002)</b>

<table>
  <tr>
    <th>Field</th> <th>Bits</th> <th>Type</th> <th>Description</th>
  </tr>
  <tr>
    <td>reserved</td>   <td>[63:8]</td>   <td>RO</td>   <td><b></b>.</td>
  </tr>
  <tr>
    <td>FRM</td>   <td>[7:5]</td>   <td>RO</td>   <td><b>Rounding Mode</b>:
       \li 000: RNE - Round to Nearest, ties to Even
       \li 001: RTZ - Round towards Zero
       \li 010: RDN - Round Down
       \li 011: RUP - Round Up
       \li 100: RMM - Round to Nearest, ties to Max Magnitude
       \li 101: Invalid. Reserved for future use.
       \li 110: Invalid. Reserved for future use.
       \li 111: Dynamic rounding mode
    </td>
  </tr>
  <tr>
    <td>reserved</td>   <td>[4:0]</td>   <td>RO</td>   <td><b></b>.</td>
  </tr>
</table>

<b>FCSR Register (0x003)</b>

<table>
  <tr>
    <th>Field</th> <th>Bits</th> <th>Type</th> <th>Description</th>
  </tr>
  <tr>
    <td>reserved</td>   <td>[63:8]</td>   <td>RO</td>   <td><b></b>.</td>
  </tr>
  <tr>
    <td>FRM</td>   <td>[7:5]</td>   <td>RO</td>   <td><b>Rounding Mode</b>:
       \li 000: RNE - Round to Nearest, ties to Even
       \li 001: RTZ - Round towards Zero
       \li 010: RDN - Round Down
       \li 011: RUP - Round Up
       \li 100: RMM - Round to Nearest, ties to Max Magnitude
       \li 101: Invalid. Reserved for future use.
       \li 110: Invalid. Reserved for future use.
       \li 111: Dynamic rounding mode
    </td>
  </tr>
  <tr>
    <td>NV</td>   <td>[4]</td>   <td>RO</td>   <td><b>Invalid Operation</b>.
     Last FPU operation status flag</td>
  </tr>
  <tr>
    <td>DZ</td>   <td>[3]</td>   <td>RO</td>   <td><b>Divide by Zero</b>.
     Last FPU operation status flag</td>
  </tr>
  <tr>
    <td>OF</td>   <td>[2]</td>   <td>RO</td>   <td><b>Overflow</b>.
     Last FPU operation status flag</td>
  </tr>
  <tr>
    <td>UF</td>   <td>[1]</td>   <td>RO</td>   <td><b>Underflow</b>.
     Last FPU operation status flag</td>
  </tr>
  <tr>
    <td>NX</td>   <td>[0]</td>   <td>RO</td>   <td><b>Inexact</b>.
     Last FPU operation status flag</td>
  </tr>
</table>

<b>MISA Register (0xf10)</b>

<table>
  <tr>
    <th>Field</th> <th>Bits</th> <th>Type</th> <th>Description</th>
  </tr>
  <tr>
    <td>MXL</td>   <td>[63:62]</td>   <td>RO</td>   <td><b>Machine XLEN</b>:
         \li 1 - 32-bits
         \li 2 - 64-bits (River CPU)
         \li 3 - 128-bits
         </td>
  </tr>
  <tr>
    <td>reserved</td>   <td>[61:26]</td>   <td>RZ</td>   <td><b></b>.</td>
  </tr>
  <tr>
    <td>Z</td>   <td>[25]</td>   <td>RZ</td>   <td>Reserved</td>
  </tr>
  <tr>
    <td>Y</td>   <td>[24]</td>   <td>RZ</td>   <td>Reserved</td>
  </tr>
  <tr>
    <td>X</td>   <td>[23]</td>   <td>RO</td>   <td>Non-standard extension present</td>
  </tr>
  <tr>
    <td>W</td>   <td>[22]</td>   <td>RZ</td>   <td>Reserved</td>
  </tr>
  <tr>
    <td>V</td>   <td>[21]</td>   <td>RO</td>   <td>Tentatively reserved for Vector extension</td>
  </tr>
  <tr>
    <td>U</td>   <td>[20]</td>   <td>RO</td>   <td>User mode implemented</td>
  </tr>
  <tr>
    <td>T</td>   <td>[19]</td>   <td>RO</td>   <td>Tentatively reserved for Transactional
          memory extension</td>
  </tr>
  <tr>
    <td>S</td>   <td>[18]</td>   <td>RO</td>   <td>Supervisor mode implemented</td>
  </tr>
  <tr>
    <td>R</td>   <td>[17]</td>   <td>RZ</td>   <td>Reserved</td>
  </tr>
  <tr>
    <td>Q</td>   <td>[16]</td>   <td>RO</td>   <td>Quad-precision floating-point extension</td>
  </tr>
  <tr>
    <td>P</td>   <td>[15]</td>   <td>RO</td>   <td>Tentatively reserved for Packed-SIMD extension</td>
  </tr>
  <tr>
    <td>O</td>   <td>[14]</td>   <td>RZ</td>   <td>Reserved</td>
  </tr>
  <tr>
    <td>N</td>   <td>[13]</td>   <td>RO</td>   <td>User-level interrupts supported</td>
  </tr>
  <tr>
    <td>M</td>   <td>[12]</td>   <td>RO</td>   <td>Integer Multiply/Divide extension</td>
  </tr>
  <tr>
    <td>L</td>   <td>[11]</td>   <td>RO</td>   <td>Tentatively reserved for Decimal
          Floating-Point extension</td>
  </tr>
  <tr>
    <td>K</td>   <td>[10]</td>   <td>RZ</td>   <td>Reserved</td>
  </tr>
  <tr>
    <td>J</td>   <td>[9]</td>   <td>RO</td>   <td>Tentatively reserved for Dynamically
          Translated Languages extension</td>
  </tr>
  <tr>
    <td>I</td>   <td>[8]</td>   <td>RO</td>   <td>RV32I/64I/128I base ISA</td>
  </tr>
  <tr>
    <td>H</td>   <td>[7]</td>   <td>RZ</td>   <td>Reserved</td>
  </tr>
  <tr>
    <td>G</td>   <td>[6]</td>   <td>RO</td>   <td>Additional standard extensions present</td>
  </tr>
  <tr>
    <td>F</td>   <td>[5]</td>   <td>RO</td>   <td>Single-precision floating-point extension</td>
  </tr>
  <tr>
    <td>E</td>   <td>[4]</td>   <td>RO</td>   <td>RV32E base ISA</td>
  </tr>
  <tr>
    <td>D</td>   <td>[3]</td>   <td>RO</td>   <td>Double-precision floating-point extension</td>
  </tr>
  <tr>
    <td>C</td>   <td>[2]</td>   <td>RO</td>   <td>Compressed extension</td>
  </tr>
  <tr>
    <td>B</td>   <td>[1]</td>   <td>RO</td>   <td>Tentatively reserved for
          Bit operations extension</td>
  </tr>
  <tr>
    <td>A</td>   <td>[0]</td>   <td>RO</td>   <td>Atomic extension</td>
  </tr>
</table>

<b>MVENDORID Register (0xf11)</b>

  This register should provide the JEDEC manufacturer ID of the provider of the
core. River CPU doesn't have a registered JEDEC identification.

<table>
  <tr>
    <th>Field</th> <th>Bits</th> <th>Type</th> <th>Description</th>
  </tr>
  <tr>
    <td>BANK</td>   <td>[63:7]</td>   <td>RO</td>   <td>
     The number of one-byte continuation JEDEC codes: \c CFG_VENDOR_ID[63:7]</td>
  </tr>
  <tr>
    <td>OFFSET</td>   <td>[6:0]</td>   <td>RO</td>   <td>
      JEDEC final byte: \c CFG_VENDOR_ID[6:0]</td>
  </tr>
</table>

<b>MARCHID Register (0xf12)</b>

<table>
  <tr>
    <th>Field</th> <th>Bits</th> <th>Type</th> <th>Description</th>
  </tr>
  <tr>
    <td>AID</td>   <td>[63:0]</td>   <td>RZ</td>   <td>Hard-wired to zero.</td>
  </tr>
</table>

<b>MIMPLEMENTATIONID Register (0xf13)</b>

<table>
  <tr>
    <th>Field</th> <th>Bits</th> <th>Type</th> <th>Description</th>
  </tr>
  <tr>
    <td>reserved</td>   <td>[63:32]</td>   <td>RZ</td>   <td><b></b>.</td>
  </tr>
  <tr>
    <td>IMPL</td>   <td>[31:0]</td>   <td>RO</td>   <td><b>Implementation</b>.
       This value can be changed via configuration parameter \c CFG_IMPLEMENTATION_ID</td>
  </tr>
</table>

<b>MHARTID Register (0xf14)</b>

<table>
  <tr>
    <th>Field</th> <th>Bits</th> <th>Type</th> <th>Description</th>
  </tr>
  <tr>
    <td>HART</td>   <td>[63:0]</td>   <td>RO</td>   <td><b>Hart ID</b>.
       This value is defined on SoC top-level via River CPU generic 
       parameter \c hartid. This value should be unique for each Core.</td>
  </tr>
</table>

<b>UEPC Register (0x041)</b>

<table>
  <tr>
    <th>Field</th> <th>Bits</th> <th>Type</th> <th>Description</th>
  </tr>
  <tr>
    <td>UEPC</td>   <td>[63:0]</td>   <td>RZ</td>   <td><b>User Exception
        program counter</b>. Always read zero.</td>
  </tr>
</table>

<b>MSTATUS Register (0x300)</b>

<table>
  <tr>
    <th>Field</th> <th>Bits</th> <th>Type</th> <th>Description</th>
  </tr>
  <tr>
    <td>SD</td>   <td>[63]</td>   <td>RO</td>   <td><b>Extensions Context Dirty</b>.
       Not implemented. Read zero.</td>
  </tr>
  <tr>
    <td>reserved</td>   <td>[62:36]</td>   <td>RZ</td>   <td><b></b>.</td>
  </tr>
  <tr>
    <td>SXL</td>   <td>[35:34]</td>   <td>RO</td>   <td><b>Supervisor mode
      support</b>:
          \li 0 - not supported (River CPU default)
          \li 1 - 32-bits
          \li 2 - 64-bits
          \li 3 - 128-bits</td>
  </tr>
  <tr>
    <td>UXL</td>   <td>[33:32]</td>   <td>RO</td>   <td><b>User mode
       support</b>:
          \li 0 - not supported
          \li 1 - 32-bits
          \li 2 - 64-bits (River CPU default)
          \li 3 - 128-bits</td>
  </tr>
  <tr>
    <td>reserved</td>   <td>[31:23]</td>   <td>RZ</td>   <td><b></b>.</td>
  </tr>
  <tr>
    <td>TSR</td>   <td>[22]</td>   <td>RO</td>   <td><b>Trap SRET</b>.
         Not implemented</td>
  </tr>
  <tr>
    <td>TW</td>   <td>[21]</td>   <td>RO</td>   <td><b>Timeout Wait</b>.
         Not implemented</td>
  </tr>
  <tr>
    <td>TVM</td>   <td>[20]</td>   <td>RO</td>   <td><b>Trap Virtual Memory</b>.
         Not implemented</td>
  </tr>
  <tr>
    <td>MXR</td>   <td>[19]</td>   <td>RO</td>   <td><b>Make executable readable</b>.
         Not implemented</td>
  </tr>
  <tr>
    <td>SUM</td>   <td>[18]</td>   <td>RO</td>   <td><b>Permit Supervisor User
         Memory</b>. Not implemented</td>
  </tr>
  <tr>
    <td>MPRV</td>   <td>[17]</td>   <td>RO</td>   <td><b>Modify Privilege</b>.
         Not implemented</td>
  </tr>
  <tr>
    <td>XS</td>   <td>[16:15]</td>   <td>RO</td>   <td>Not implemented</td>
  </tr>
  <tr>
    <td>FS</td>   <td>[14:13]</td>   <td>RO</td>   <td>Extension context status:
       \li always 0 - when FPU disabled (\c CFG_HW_FPU_ENABLE = false)
       \li always 1 - when FPU enabled (\c CFG_HW_FPU_ENABLE = true)
      </td>
  </tr>
  <tr>
    <td>MPP</td>   <td>[12:11]</td>   <td>RW</td>   <td>Privilege level
        prior the trap</td>
  </tr>
  <tr>
    <td>reserved</td>   <td>[10:9]</td>   <td>RZ</td>   <td><b></b>.</td>
  </tr>
  <tr>
    <td>SPP</td>   <td>[8]</td>   <td>RO</td>   <td>Not implemented</td>
  </tr>
  <tr>
    <td>MPIE</td>   <td>[7]</td>   <td>RW</td>   <td>Interrupt Enable bit
       prior the trap</td>
  </tr>
  <tr>
    <td>reserved</td>   <td>[6]</td>   <td>RZ</td>   <td><b></b>.</td>
  </tr>
  <tr>
    <td>SPIE</td>   <td>[5]</td>   <td>RO</td>   <td>Not implemented</td>
  </tr>
  <tr>
    <td>UPIE</td>   <td>[4]</td>   <td>RO</td>   <td>Not implemented</td>
  </tr>
  <tr>
    <td>MIE</td>   <td>[3]</td>   <td>RW</td>   <td>Interrupt Enable for
         Machine mode:
         \li 0 - Interrupts disabled
         \li 1 - Interrupts enabled</td>
  </tr>
  <tr>
    <td>reserved</td>   <td>[2]</td>   <td>RZ</td>   <td><b></b>.</td>
  </tr>
  <tr>
    <td>SIE</td>   <td>[1]</td>   <td>RO</td>   <td>Not implemented</td>
  </tr>
  <tr>
    <td>UIE</td>   <td>[0]</td>   <td>RW</td>   <td>Interrupt Enable for
        User mode:
         \li 0 - Interrupts disabled
         \li 1 - Interrupts enabled</td>
  </tr>
</table>

<b>MEDELEG Register (0x302)</b>

<table>
  <tr>
    <th>Field</th> <th>Bits</th> <th>Type</th> <th>Description</th>
  </tr>
  <tr>
    <td>SE</td>   <td>[63:0]</td>   <td>RZ</td>   <td><b>Synchronous
        Exceptions</b>. Not implemented.</td>
  </tr>
</table>

<b>MIDELEG Register (0x303)</b>

<table>
  <tr>
    <th>Field</th> <th>Bits</th> <th>Type</th> <th>Description</th>
  </tr>
  <tr>
    <td>IRQS</td>   <td>[63:0]</td>   <td>RZ</td>   <td><b>Interrupts</b>.
         Not implemented</td>
  </tr>
</table>

<b>MIE Register (0x304)</b>

<table>
  <tr>
    <th>Field</th> <th>Bits</th> <th>Type</th> <th>Description</th>
  </tr>
  <tr>
    <td>reserved</td>   <td>[63:12]</td>   <td>RZ</td>   <td><b></b>.</td>
  </tr>
  <tr>
    <td>MEIE</td>   <td>[11]</td>   <td>RW</td>   <td><b>Machine External 
        Interrupt Enable</b>. This bit is directly controlled via \c MSTATUS
        register.</td>
  </tr>
  <tr>
    <td>reserved</td>   <td>[10]</td>   <td>RZ</td>   <td><b></b>.</td>
  </tr>
  <tr>
    <td>SEIE</td>   <td>[9]</td>   <td>RW</td>   <td><b>Supervisor External
        Interrupt Enable</b>. This bit is directly controlled via \c MSTATUS
        register.</td>
  </tr>
  <tr>
    <td>UEIE</td>   <td>[8]</td>   <td>RW</td>   <td><b>User External
        Interrupt Enable</b>. This bit is directly controlled via \c MSTATUS
        register.</td>
  </tr>
  <tr>
    <td>MTIE</td>   <td>[7]</td>   <td>RW</td>   <td><b>Machine Timer IE</b>.
        River CPU doesn't implement wallclock timer only external General Purposes
        Timers</td>
  </tr>
  <tr>
    <td>reserved</td>   <td>[6]</td>   <td>RZ</td>   <td><b></b>.</td>
  </tr>
  <tr>
    <td>STIE</td>   <td>[5]</td>   <td>RW</td>   <td><b>Supervisor Timer IE</b>.
        Wallclock timer not implemented</td>
  </tr>
  <tr>
    <td>UTIE</td>   <td>[4]</td>   <td>RW</td>   <td><b>User Timer IE</b>.
        Wallclock timer not implemented</td>
  </tr>
  <tr>
    <td>MSIE</td>   <td>[3]</td>   <td>RW</td>   <td><b>Machine Software
        Interrupt Enable</b>. Not implemented</td>
  </tr>
  <tr>
    <td>reserved</td>   <td>[2]</td>   <td>RZ</td>   <td><b></b>.</td>
  </tr>
  <tr>
    <td>SSIE</td>   <td>[1]</td>   <td>RW</td>   <td><b>Supervisor Software
        Interrupt Enable</b>. Not implemented</td>
  </tr>
  <tr>
    <td>USIE</td>   <td>[0]</td>   <td>RW</td>   <td><b>Machine Software
        Interrupt Enable</b>. Not implemented</td>
  </tr>
</table>

<b>MTVEC Register (0x305)</b>

<table>
  <tr>
    <th>Field</th> <th>Bits</th> <th>Type</th> <th>Description</th>
  </tr>
  <tr>
    <td>BASE</td>   <td>[63:1]</td>   <td>RW</td>   <td><b>Trap-Vector
       Base Address</b>. All Interrupts cause the \c pc to be set to
       the address in this field</td>
  </tr>
  <tr>
    <td>MODE</td>   <td>[0]</td>   <td>RW</td>   <td><b>Trap Mode</b>:
        \li 0 = Direct mode. All traps cause the \c pc to be set to
                the address in BASE field.
        \li 1 = Vectored. Not implemented.</td>
  </tr>
</table>

<b>MSCRATCH Register (0x340)</b>

<table>
  <tr>
    <th>Field</th> <th>Bits</th> <th>Type</th> <th>Description</th>
  </tr>
  <tr>
    <td>MSCRATCH</td>   <td>[63:0]</td>   <td>RW</td>   <td><b>Machine Scratch</b>.
        Typically, it is used to hold a pointer to a machine-mode hart-local
        context space and swapped with a user register upon entry to an
        M-mode trap handler.</td>
  </tr>
</table>

<b>MEPC Register (0x341)</b>

<table>
  <tr>
    <th>Field</th> <th>Bits</th> <th>Type</th> <th>Description</th>
  </tr>
  <tr>
    <td>MEPC</td>   <td>[63:0]</td>   <td>RW</td>   <td><b>Machine
        Exception Program Counter</b>. Register specifies the jump address
        after execution of \c mret instruction.</td>
  </tr>
</table>

<b>MCAUSE Register (0x342)</b>

<table>
  <tr>
    <th>Field</th> <th>Bits</th> <th>Type</th> <th>Description</th>
  </tr>
  <tr>
    <td>IRQ</td>   <td>[62:0]</td>   <td>R0</td>   <td><b>Interrupt flag</b>.
       \li '0' - Exception trap
       \li '1' - Interrupt trap
       </td>
  </tr>
  <tr>
    <td>CODE</td>   <td>[62:0]</td>   <td>R0</td>   <td><b>Exception Code</b>.
      See tables 4-6 and 4-7 with the information about trap codes</td>
  </tr>
</table>

<b>Exception Codes</b>

<center>
| Val| Name          | Description
|:--:|:-------------:|:-------------------------------
| 0  | InstrMisalign | Instruction address misaligned
| 1  | InstrFault    | Instruction access fault
| 2  | InstrIllegal  | Illegal instruction
| 3  | Breakpoint    | Software berakpoint (instruction EBREAK)
| 4  | LoadMisalign  | Load address misaligned
| 5  | LoadFault     | Load access fault
| 6  | StoreMisalign | Store address misaligned
| 7  | StoreFault    | Store address fault
| 8  | CallFromUMode | Environment call from U-mode (instruction ECALL)
| 9  | CallFromSMode | Not used
| 10 | CallFromHMode | Not used
| 11 | CallFromMMode | Environment call from M-mode (instruction ECALL)
| 12 | InstrPageFault | Not used
| 13 | LoadPageFault  | Not used
| 14 | reserved       | Not used
| 15 | StorePageFault | Not used
| 16 | StackOverflow  | Stack pointer (sp) is below than overflow limit
| 17 | StackUnderflow | Stack pointer (sp) is higher than underflow limit

@latexonly \begin{tblid} @endlatexonly
CODE value in a case of exception.
@latexonly \end{tblid} @endlatexonly
</center>

<b>Interrupt Codes</b>

<center>
| Val| Name          | Description
|:--:|:-------------:|:-------------------------
| 0  | USoftware     | Not used
| 1  | SSoftware     | Not used
| 2  | HSoftware     | Not used
| 3  | MSoftware     | Not used
| 4  | UTimer        | Not used
| 5  | STimer        | Not used
| 6  | HTimer        | Not used
| 7  | MTimer        | Not used
| 8  | UExternal     | Not used
| 9  | SExternal     | Not used
| 10 | HExternal     | Not used
| 11 | MExternal     | Interrupt request from an external IRQ controller

@latexonly \begin{tblid} @endlatexonly
CODE value in a case of interrupt.
@latexonly \end{tblid} @endlatexonly
</center>


<b>MBADADDR Register (0x343)</b>

<table>
  <tr>
    <th>Field</th> <th>Bits</th> <th>Type</th> <th>Description</th>
  </tr>
  <tr>
    <td>MBADADDR</td>   <td>[63:0]</td>   <td>RO</td>   <td><b>Bad Address</b>.
         Registers captures bad program counter on an instruction fault or 
         memory access address on an invalid data load/store operations.</td>
  </tr>
</table>

<b>MIP Register (0x344)</b>

<table>
  <tr>
    <th>Field</th> <th>Bits</th> <th>Type</th> <th>Description</th>
  </tr>
  <tr>
    <td>reserved</td>   <td>[63:12]</td>   <td>RZ</td>   <td><b></b>.</td>
  </tr>
  <tr>
    <td>MEIP</td>   <td>[11]</td>   <td>RW</td>   <td><b>Machine External 
        Interrupt Pending</b>. Not implemented.</td>
  </tr>
  <tr>
    <td>reserved</td>   <td>[10]</td>   <td>RZ</td>   <td><b></b>.</td>
  </tr>
  <tr>
    <td>SEIP</td>   <td>[9]</td>   <td>RW</td>   <td><b>Supervisor External
        Interrupt Pending</b>. Not implemented.</td>
  </tr>
  <tr>
    <td>UEIP</td>   <td>[8]</td>   <td>RW</td>   <td><b>User External
        Interrupt Pending</b>. Not implemented.</td>
  </tr>
  <tr>
    <td>MTIP</td>   <td>[7]</td>   <td>RW</td>   <td><b>Machine Timer IP</b>.
        River CPU doesn't implement wallclock timer only external General Purposes
        Timers</td>
  </tr>
  <tr>
    <td>reserved</td>   <td>[6]</td>   <td>RZ</td>   <td><b></b>.</td>
  </tr>
  <tr>
    <td>STIP</td>   <td>[5]</td>   <td>RW</td>   <td><b>Supervisor Timer IP</b>.
        Wallclock timer not implemented</td>
  </tr>
  <tr>
    <td>UTIP</td>   <td>[4]</td>   <td>RW</td>   <td><b>User Timer IP</b>.
        Wallclock timer not implemented</td>
  </tr>
  <tr>
    <td>MSIP</td>   <td>[3]</td>   <td>RW</td>   <td><b>Machine Software
        Interrupt Pending</b>. Not implemented</td>
  </tr>
  <tr>
    <td>reserved</td>   <td>[2]</td>   <td>RZ</td>   <td><b></b>.</td>
  </tr>
  <tr>
    <td>SSIP</td>   <td>[1]</td>   <td>RW</td>   <td><b>Supervisor Software
        Interrupt Pending</b>. Not implemented</td>
  </tr>
  <tr>
    <td>USIP</td>   <td>[0]</td>   <td>RW</td>   <td><b>Machine Software
        Interrupt Pending</b>. Not implemented</td>
  </tr>
</table>

 @section cpu_stack_protection_section Stack Protection

  River CPU implements two special non-standard CSR registers \c MSTACKOVR
and \c MSTACKUND. These dedicated registers allows to setup the boundaries
at which the exception event is generated if the 'sp' comes out of these limits.


<b>MSTACKOVR Register (0x350)</b>

<table>
  <tr>
    <th>Field</th> <th>Bits</th> <th>Type</th> <th>Description</th>
  </tr>
  <tr>
    <td>SOVR</td>   <td>[63:0]</td>   <td>RW</td>   <td><b>Stack Overflow
         border</b>. Value automatically cleared just after exception generated:
         \li zero - Stack Overflow exception disabled
         \li non-zero - Raise Stack Overflow exception if register value \c sp
                        is less than this value.</td>
  </tr>
</table>

<b>MSTACKUND Register (0x351)</b>

<table>
  <tr>
    <th>Field</th> <th>Bits</th> <th>Type</th> <th>Description</th>
  </tr>
  <tr>
    <td>SUND</td>   <td>[63:0]</td>   <td>RW</td>   <td><b>Stack Underflow
         border</b>. Value automatically cleared just after exception generated:
         \li zero - Stack Overflow exception disabled
         \li non-zero - Raise Stack Underflow exception if register value \c sp
                        is greater than this value.</td>
  </tr>
</table>

<b>MPU_ADDR Register (0x352)</b>

<table>
  <tr>
    <th>Field</th> <th>Bits</th> <th>Type</th> <th>Description</th>
  </tr>
  <tr>
    <td>reserved</td>   <td>[63:BUS_ADDR_WIDTH]</td>   <td>WO</td>   <td><b></b>.</td>
  </tr>
  <tr>
    <td>ADDR</td>   <td>[BUS_ADDR_WIDTH-1:0]</td>   <td>WO</td>   <td><b>MPU Address</b>.
     Base address of programming region. This value applied to the MPU region on write
     access into the register \c MPU_CTRL</td>
  </tr>
</table>

<b>MPU_MASK Register (0x353)</b>

<table>
  <tr>
    <th>Field</th> <th>Bits</th> <th>Type</th> <th>Description</th>
  </tr>
  <tr>
    <td>reserved</td>   <td>[63:BUS_ADDR_WIDTH]</td>   <td>WO</td>   <td><b></b>.</td>
  </tr>
  <tr>
    <td>MASK</td>   <td>[BUS_ADDR_WIDTH-1:0]</td>   <td>WO</td>   <td><b>MPU Address Mask</b>.
     Address mask defining region size. This value applied to the MPU region on write
     access into the register \c MPU_CTRL.</td>
  </tr>
</table>

<b>MPU_CTRL Register (0x354)</b>

<table>
  <tr>
    <th>Field</th> <th>Bits</th> <th>Type</th> <th>Description</th>
  </tr>
  <tr>
    <td>IDX</td>   <td>[15:8]</td>   <td>RW</td>   <td><b>Region Index</b>.
     This field specify region index that will be modified on write access to this
     register on write access.
     This value contains total number of available regions \c CFG_MPU_TBL_SIZE
     on read access</td>
  </tr>
  <tr>
    <td>ENA</td>   <td>[4]</td>   <td>WO</td>   <td><b>Region Enable</b>.
     Enable region:
       \li 0 = region disabled (not used)
       \li 1 = region enabled</td>
  </tr>
  <tr>
    <td>CACHABLE</td>   <td>[3]</td>   <td>WO</td>   <td><b>Caching Enable</b>.
     Enable region for caching:
       \li 0 = caching disabled
       \li 1 = caching enabled</td>
  </tr>
  <tr>
    <td>EXEC</td>   <td>[2]</td>   <td>WO</td>   <td><b>Execute Enable</b>.
     Enable region for the instruction execution:
       \li 0 = execution disabled
       \li 1 = execution enabled</td>
  </tr>
  <tr>
    <td>RD</td>   <td>[1]</td>   <td>WO</td>   <td><b>Read Enable</b>.
     Enable region for reading:
       \li 0 = read disabled
       \li 1 = read enabled</td>
  </tr>
  <tr>
    <td>WR</td>   <td>[0]</td>   <td>WO</td>   <td><b>Write Enable</b>.
     Enable region for writing:
       \li 0 = write disabled
       \li 1 = write enabled</td>
  </tr>
</table>


 @section trap_handle_section Exceptions and Interrupts

  CPU River supports two types of traps:

\li Unmaskable Exceptions (Bit \c MCAUSE[64] = '0')
\li External Interrupts (Bit \c MCAUSE[64] = '1')

  In a case of occured valid trap CPU executes the following steps:

\li Store Trap type and Trap index into \c MCAUSE register
\li Store next program counter value (npc) into the register \c MEPC or \c UEPC
    depending of the current processor mode.
\li Fetch and execute instruction stored in the address specified by register \c MTVEC
    if the occured trap is an Interrupt. If the current trap is an Exception
    then CPU jumps to address accordingly with the configuration <b>table 4-6</b>.
\li CPU switches into Machine Mode and properly shows its status in the register
    \c MSTATUS.
\li All interrupts are masked (\c MIE).

<center>
| Parameter                    | Address    | Description
|:----------------------------:|:-----------|:--------------------------------------
| CFG_NMI_RESET_VECTOR         | 0x00000000 | CPU Reset vector
| CFG_NMI_INSTR_UNALIGNED_ADDR | 0x00000008 | Instruction address misaligned handler
| CFG_NMI_INSTR_FAULT_ADDR     | 0x00000010 | Instruction address fault handler
| CFG_NMI_INSTR_ILLEGAL_ADDR   | 0x00000018 | Illegal or unsupported instruction handler
| CFG_NMI_BREAKPOINT_ADDR      | 0x00000020 | Software breakpoint (EBREAK) handler
| CFG_NMI_LOAD_UNALIGNED_ADDR  | 0x00000028 | Load address misaligned handler
| CFG_NMI_LOAD_FAULT_ADDR      | 0x00000030 | Load access fault handler
| CFG_NMI_STORE_UNALIGNED_ADDR | 0x00000038 | Store address misaligned handler
| CFG_NMI_STORE_FAULT_ADDR     | 0x00000040 | Store access fault handler
| CFG_NMI_CALL_FROM_UMODE_ADDR | 0x00000048 | Environment call from U-mode handler
| CFG_NMI_CALL_FROM_SMODE_ADDR | 0x00000050 | Environment call from S-mode handler
| CFG_NMI_CALL_FROM_HMODE_ADDR | 0x00000058 | Environment call from H-mode handler
| CFG_NMI_CALL_FROM_MMODE_ADDR | 0x00000060 | Environment call from M-mode handler
| CFG_NMI_INSTR_PAGE_FAULT_ADDR| 0x00000068 | MPU prohibits instruction execution
| CFG_NMI_LOAD_PAGE_FAULT_ADDR | 0x00000070 | MPU prohibits data loading
| CFG_NMI_STORE_PAGE_FAULT_ADDR| 0x00000078 | MPU prohibits data storing
| CFG_NMI_STACK_OVERFLOW_ADDR  | 0x00000080 | Stack Overflow handler
| CFG_NMI_STACK_UNDERFLOW_ADDR | 0x00000088 | Stack Underflow handler

@latexonly \begin{tblid} @endlatexonly
CPU River Exceptions Table RTL configuration.
@latexonly \end{tblid} @endlatexonly
</center>

@note To reduce memory usage by Exception Table it is possible to assign all
      exceptions into one address and manage the occured trap type using
      the value stored in the \c MCAUSE register.

@section cpu_example_section C-code example

  The following C-example demonstrates how to read current Core ID using
inline assembler:

@code
    int fw_get_cpuid() {
        int ret;
        asm("csrr %0, mhartid" : "=r" (ret));
        return ret;
    }
@endcode

*/